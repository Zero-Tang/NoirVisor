/*
 * NoirVisor Core in Rust
 * 
 * Copyright (c) Zero Tang, 2024. All rights reserved.
 * 
 * This file defines AMD64-specific constants for NoirVisor Core in Rust.
 * 
 * This program is distributed in the hope that it will be useful, but 
 * without any warranty (no matter implied warranty or merchantability
 * or fitness for a particular purpose, etc.).
 */

// CPUID
pub mod cpuid
{
	// List all indices of CPUID.
	pub const CPUID_STD_PLATFORM_QOS_MONITORING:u32=0xF;
	pub const CPUID_STD_PLATFORM_QOS_ENFORCEMENT:u32=0x10;

	pub const CPUID_EXT_SECURE_VIRTUAL_MACHINE_FEATURE:u32=0x8000000A;
	pub const CPUID_EXT_1GB_TLB_CHARACTERISTICS:u32=0x80000019;
	pub const CPUID_EXT_INSTRUCTION_OPTIMIZATIONS:u32=0x8000001A;
	pub const CPUID_EXT_INSTRUCTION_BASED_SAMPLING_CAPABILITY:u32=0x8000001B;
	pub const CPUID_EXT_LIGHTWEIGHT_PROFILING_CAPABILITY:u32=0x8000001C;
	pub const CPUID_EXT_CACHE_TOPOLOGY_INFORMATION:u32=0x8000001D;
	pub const CPUID_EXT_PROCESSOR_TOPOLOGY_INFORMATION:u32=0x8000001E;
	pub const CPUID_EXT_ENCRYPTED_MEMORY_CAPABILITY:u32=0x8000001F;
	pub const CPUID_EXT_PLATFORM_QOS_EXTENDED_FEATURE:u32=0x80000020;
	pub const CPUID_EXT_EXTENDED_FEATURE_ID2:u32=0x80000021;
	pub const CPUID_EXT_EXTENDED_PERFORMANCE_MONITORING_DEBUG:u32=0x80000022;
	pub const CPUID_EXT_MULTI_KEY_ENCRYPTED_MEMORY_CAPABILITY:u32=0x80000023;
	pub const CPUID_EXT_EXTENDED_CPU_TOPOLOGY_INFORMATION:u32=0x80000026;

	// Do not exhaustively enumerate CPUID bit fields. Only list what we are interested.
	// CPUID Flags for Extended Processor and Feature Identifiers.
	/// Use this flag for CPUID[EAX=0x80000001].ECX
	pub const CPUID_SVM:u32=0x4;
	/// Use this flag for CPUID[EAX=0x80000001].ECX
	pub const CPUID_SKINIT:u32=0x1000;
	
	// CPUID Flags for SVM Features.
	pub const CPUID_SVM_NPT:u32=0x00000001;
	pub const CPUID_SVM_LBR:u32=0x00000002;
	pub const CPUID_SVM_LOCK:u32=0x00000004;
	pub const CPUID_SVM_NEXT_RIP_SAVING:u32=0x00000008;
	pub const CPUID_SVM_TSC_MSR:u32=0x00000010;
	pub const CPUID_SVM_VMCB_CLEAN:u32=0x00000020;
	pub const CPUID_SVM_FLUSH_BY_ASID:u32=0x00000040;
	pub const CPUID_SVM_DECODE_ASSIST:u32=0x00000080;
	pub const CPUID_SVM_PMC_VIRTUALIZATION:u32=0x00000100;
	pub const CPUID_SVM_PAUSE_FILTER:u32=0x00000400;
	pub const CPUID_SVM_PAUSE_FILTER_THRESHOLD:u32=0x00001000;
	pub const CPUID_SVM_AVIC:u32=0x00002000;
	pub const CPUID_SVM_NESTED_VMLOAD_VMSAVE:u32=0x00008000;
	pub const CPUID_SVM_VGIF:u32=0x00010000;
	pub const CPUID_SVM_GMET:u32=0x00020000;
	pub const CPUID_SVM_X2AVIC:u32=0x00040000;
	pub const CPUID_SVM_SSS_CHECK:u32=0x00080000;
	pub const CPUID_SVM_SPEC_CTRL_VIRTUALIZATION:u32=0x00100000;
	pub const CPUID_SVM_READ_ONLY_GPT:u32=0x00200000;
	pub const CPUID_SVM_HOST_MCE_OVERRIDE:u32=0x00800000;
	pub const CPUID_SVM_TLBI_CTRL:u32=0x01000000;
	pub const CPUID_SVM_VNMI:u32=0x02000000;
	pub const CPUID_SVM_VIBS:u32=0x04000000;
	pub const CPUID_SVM_EXT_LVT_AVIC_ACCESS_CHANGE:u32=0x08000000;
	pub const CPUID_SVM_NESTED_VMCB_ADDRESS_CHECK:u32=0x10000000;
	pub const CPUID_SVM_BUS_LOCK_THRESHOLD:u32=0x20000000;
	pub const CPUID_SVM_IDLE_HALT_INTERCEPTION:u32=0x40000000;
}

pub mod msr
{
	pub const MSR_HWCR:u32=0xC0010015;

	// SVM/SMM-related MSRs
	pub const MSR_SMI_TRIG_IO_CYCLE:u32=0xC0010056;
	pub const MSR_PSTATE_CURRENT_LIMIT:u32=0xC0010061;
	pub const MSR_PSTATE_CONTROL:u32=0xC0010062;
	pub const MSR_PSTATE_STATUS:u32=0xC0010063;
	pub const MSR_TSC_RATIO:u32=0xC0010104;
	pub const MSR_SMBASE:u32=0xC0010111;
	pub const MSR_SMM_ADDR:u32=0xC0010112;
	pub const MSR_SMM_MASK:u32=0xC0010113;
	pub const MSR_VMCR:u32=0xC0010114;
	pub const MSR_IGNNE:u32=0xC0010115;
	pub const MSR_SMM_CTRL:u32=0xC0010116;
	pub const MSR_HSAVE_PA:u32=0xC0010117;
	pub const MSR_SVM_KEY:u32=0xC0010118;
	pub const MSR_SMM_KEY:u32=0xC0010119;
	pub const MSR_LOCAL_SMI_STATUS:u32=0xC001011A;
	pub const MSR_APIC_DOORBELL:u32=0xC001011B;
	pub const MSR_VMPAGE_FLUSH:u32=0xC001011E;
	pub const MSR_VIRT_SPEC_CTRL:u32=0xC001011F;
	pub const MSR_SVM_GHCB_PA:u32=0xC0010130;
	pub const MSR_SEV_STATUS:u32=0xC0010131;
	pub const MSR_RMP_BASE:u32=0xC0010132;
	pub const MSR_RMP_END:u32=0xC0010133;
	pub const MSR_GUEST_TSC_FREQ:u32=0xC0010134;

	// EFER
	pub const MSR_EFER_SCE:u64=0x00000001;
	pub const MSR_EFER_LME:u64=0x00000100;
	pub const MSR_EFER_LMA:u64=0x00000400;
	pub const MSR_EFER_NXE:u64=0x00000800;
	pub const MSR_EFER_SVME:u64=0x00001000;
	pub const MSR_EFER_LMSLE:u64=0x00002000;
	pub const MSR_EFER_FFXSR:u64=0x00004000;
	pub const MSR_EFER_TCE:u64=0x00008000;
	pub const MSR_EFER_MCOMMIT:u64=0x00020000;
	pub const MSR_EFER_INTWB:u64=0x00040000;
	pub const MSR_EFER_UAIE:u64=0x00100000;
	pub const MSR_EFER_AIBRSE:u64=0x00200000;

	// SVM Control Register Flags
	pub const MSR_VMCR_DPD:u64=0x00000001;
	pub const MSR_VMCR_R_INIT:u64=0x00000002;
	pub const MSR_VMCR_DISA20M:u64=0x00000004;
	pub const MSR_VMCR_LOCK:u64=0x00000008;
	pub const MSR_VMCR_SVMDIS:u64=0x00000010;

	// SMM Control Register Flags
	pub const MSR_SMMCTRL_DISMISS:u64=0x00000001;
	pub const MSR_SMMCTRL_ENTER:u64=0x00000002;
	pub const MSR_SMMCTRL_SMI_CYCLE:u64=0x00000004;
	pub const MSR_SMMCTRL_EXIT:u64=0x00000008;
	pub const MSR_SMMCTRL_RSM_CYCLE:u64=0x00000010;
}